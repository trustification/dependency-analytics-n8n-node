import type { IExecuteFunctions, INodeExecutionData, IHttpRequestOptions } from 'n8n-workflow';
import { authedRequest, chooseCredential, defaultJsonHeaders, getBase } from '../utils/http';
import { simplifyOne } from '../utils/simplify';
import { parsePurls } from '../utils/parsePurls';
import { throwError } from '../utils/errors';

export async function get({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
	const credentialName = chooseCredential(ctx, itemIndex);
	const base = getBase(ctx, itemIndex);
	const identifierRaw = (ctx.getNodeParameter('identifier', itemIndex, '') as string).trim();
	if (!identifierRaw) throwError(ctx.getNode(), 'ID is required in "Get" mode.', itemIndex);

	const options: IHttpRequestOptions = {
		method: 'GET',
		url: `${base}/vulnerability/${encodeURIComponent(identifierRaw)}`,
		returnFullResponse: false,
		headers: defaultJsonHeaders,
	};

	const res = await authedRequest(ctx, credentialName, options);
	const simplify = ctx.getNodeParameter('simplify', itemIndex, true) as boolean;
	return simplify ? { ...simplifyOne('vulnerability', res) } : res;
}

export async function getMany({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
	const credentialName = chooseCredential(ctx, itemIndex);
	const base = getBase(ctx, itemIndex);
	const limit = (ctx.getNodeParameter('limit', itemIndex, 50) as number) || 50;

	const options: IHttpRequestOptions = {
		method: 'GET',
		url: `${base}/vulnerability`,
		qs: { limit },
		returnFullResponse: false,
		headers: defaultJsonHeaders,
	};

	const res = (await authedRequest(ctx, credentialName, options)) as any;
	const items: any[] = Array.isArray(res?.items) ? res.items.slice(0, limit) : [];
	const simplify = ctx.getNodeParameter('simplify', itemIndex, true) as boolean;

	const finalItems = simplify ? items.map((it) => simplifyOne('vulnerability', it)) : items;

	return [{ json: { ...res, items: finalItems } } as INodeExecutionData];
}

export async function analyze({ ctx, itemIndex }: { ctx: IExecuteFunctions; itemIndex: number }) {
	const credentialName = chooseCredential(ctx, itemIndex);
	const base = getBase(ctx, itemIndex);
	const inputType = ctx.getNodeParameter('inputType', itemIndex) as 'sbomSha256' | 'purls';

	if (inputType === 'purls') {
		const raw = ctx.getNodeParameter('purlsRaw', itemIndex) as unknown;
		const purls = parsePurls(raw, ctx, itemIndex);
		if (purls.length === 0) throwError(ctx.getNode(), 'Provide at least one PURL.', itemIndex);

		const options: IHttpRequestOptions = {
			method: 'POST',
			url: `${base}/vulnerability/analyze`,
			body: { purls },
			json: true,
		};

		try {
			const res = await authedRequest(ctx, credentialName, options);
			return [{ json: res } as INodeExecutionData];
		} catch (err: any) {
			if (ctx.continueOnFail()) {
				return [{ json: { error: err.message, request: { purls } } } as INodeExecutionData];
			}
			throw err;
		}
	}

	// inputType === 'sbomSha256'
	const q = (ctx.getNodeParameter('sbomSha256', itemIndex) as string)?.trim();
	if (!q) throwError(ctx.getNode(), 'SBOM Query is required for Analyze (SBOM Lookup).', itemIndex);

	// SBOM by sha256
	const listOpts: IHttpRequestOptions = {
		method: 'GET',
		url: `${base}/sbom/sha256:${q}`,
		qs: { query: q },
		returnFullResponse: false,
	};

	const listResp = (await authedRequest(ctx, credentialName, listOpts)) as any;
	const sbomId = listResp?.id;
	if (!sbomId) throwError(ctx.getNode(), `No SBOM found for query "${q}".`, itemIndex);

	// Advisories for SBOM
	const advOpts: IHttpRequestOptions = {
		method: 'GET',
		url: `${base}/sbom/${encodeURIComponent(sbomId)}/advisory`,
		returnFullResponse: false,
	};

	const advisories = await authedRequest(ctx, credentialName, advOpts);

	return [{ json: { sbomId, advisories } } as INodeExecutionData];
}
